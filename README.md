# Парсер из конфига в JSON
Парсит строку конфига и складывает результат в список словарей.
Исходный формат крайне упрощенная и менее формальная версия JSON.
Внутри каждого блока может быть призвольное количество подблоков выделенных
скобками определения блока.

Пример: '{i = 4, p = 100}, {t = 4, e = 100, n = {{m = 4, r = 100}, n = name}}'
Пример: 'value1, value2, value3'

## Режимы работы

### mode = 'v1'. По умолчанию.
Все словари будут завернуты в словарь

Строка: 'one = two, item = {count = 4.5, price = 100, name = {name1 = name}}'
Результат:

{
    "one": "two",
    "item": [
        {
            "itemsCount": 4.5,
            "price": 100,
            "name": [
                {
                    "name1": "my_name"
                }
            ]
        }
    ]
}

### mode = 'v2'
Разворачивает все списки единичной длины.
Для заворачивания необходимо указать в ключе суффикс '[]'.
Сам суффик в итоговом JSON будет отрезан.
ВАЖНО! Опция заворчивает все типы кроме списков!
См. ключи c суффиксом в примере

Строка: ```'one[] = two, item = {сount = 4.5, price = 100, name[] = {n = m, l = o}}'```

Результат:
```
{
    "one": [
        "two"
    ],
    "item": {
        "count": 4.5,
        "price": 100,
        "name": [
            {
                "n": "m",
                "l": "o"
            }
        ]
    }
}
```
### Параметры

#### unwrap_list
Нужно ли вытаскивать словари из списков единичной длины.
False (по умолчанию) вытаскивает из списков все обьекты КРОМЕ словарей.
True - вынимает из список ВСЕ типы обьектов, включая словари.
Игнорирует суффикс list_marker (принудительно разворачивает) для mode = v2

Строка: ```'one[] = two, item = {count = 4.5, price = 100, name[] = {name1 = name}}'```

Результат:
```
{
    "one": "two",
    "item": {
        "count": 4.5,
        "price": 100,
        "name": {
            "name1": "my_name"
        }
    }
}
```
#### br_block
Тип скобок выделяющих подблоки. '{}' по умолчанию.

#### br_list
Тип скобок выделяющих списки. '[]' по умолчанию.

ВАЖНО! Нельзя переопределять значение по умолчанию!
Внутри допустима любая вложенность, но исключительно в синтаксисе питона.
Недопустимо использовать одновременно упрощенный синтаксис и квадратные скобки.
Строки обязательно обрамлены кавычками. Словари с полным соблюдением синтаксиса.

Строка: ```{['one', ['two', 3, 4], {'one': 'the choose one!'}]}```

Результат:
```
[
    "one",
    [
        "two",
        3,
        4
    ],
    {
        "one": "the choose one!"
    }
]
```
Аналогичного результата можно достигнуть и классическим, упрощенным синтаксисом
Строка {one, {two, 3, 4}, {one = the choose one!}} дасть идентичный верхнему результат.
Может пригодиться для задания, например, пустых списков или простых конструкций.

#### sep_base
Базовый разделитель элементов. ',' по умолчанию.

#### sep_dict
Разделитель ключ-значение элементов словаря. '=' по умолчанию.

#### sep_block
Синтаксический сахар для разделения блоков. '|' по умолчанию.

Запись: ```'0, 6| 7 = 7, zr = 0, one, tw = {2 = d}, tv = {2 = dv | 3 = tr} | a, b'```,

будет идентична: ```'{0, 6}, {7 = 7, zr = 0, one, tw = {2 = d}, tv = {{2 = dv}, {3 = tr}}}, {a, b}'```,

#### to_num
Нужно ли пытаться преобразовывать значения в числа.
True (по умолчанию) пытается преобразовать.

#### raw_pattern
Символ маркирующий строку которую не нужно разбирать,
'"' (двойная кавычка) по умолчанию.
Строки начинающиеся с символа raw_pattern не парсятся и сохраняются как есть.

#### list_marker
Суффикс пометки ключа для заворачивания содержимого в словарь для v2.
'[]' по умолчанию. Будет отрезан от ключа в любой версии парсера.

#### is_raw
Указание надо ли парсить строку или нет. False по умаолчанию.
False (по умолчанию) - парсит строку по всем правилам, с учётом raw_pattern.
True - не парсит, возвращает как есть.

#### \_force_unwrap
Указатель, что пришли из внутреннего блока который
всегда нужно разворачивать.

